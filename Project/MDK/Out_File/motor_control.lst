C251 COMPILER V5.60.0,  motor_control                                                      13/12/23  20:03:26  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE motor_control
OBJECT MODULE PLACED IN .\Out_File\motor_control.obj
COMPILER INVOKED BY: E:\NIEZS\ARM\KeilC251\C251\BIN\C251.EXE ..\CODE\motor_control.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE
                    - INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER
                    -\inc;..\USER\src) DEBUG PRINT(.\Out_File\motor_control.lst) TABS(2) OBJECT(.\Out_File\motor_control.obj) 

stmt  level    source

    1          /**
    2            ******************************************************************************
    3            * @author  Pump_Li
    4            * @version V1.0.0
    5            * @date    2023.3.13
    6            * @brief    电机控制
    7            ******************************************************************************
    8            * @attention
    9            * 
   10            ******************************************************************************
   11            */
   12           /* Includes ------------------------------------------------------------------*/
   13          #include "headfile.h"
   14          
   15          /* Private Define ------------------------------------------------------------*/
   16          int16 Left_Encoder = 0;     //左编码器的值
   17          int16 Right_Encoder = 0;    //右编码器的值
   18          int16 Average_Encoder = 0;  //左右编码器平均值
   19          int16 Sum_Encoder = 0;      //编码器脉冲和
   20          int32 distance = 0;         //车子行走的路程
   21          
   22          //int16 K_diff = 0 ;          //差速系数
   23          
   24          
   25          
   26          float K_P_L = 3500;//800
   27          float K_I_L = 20;//80
   28          float K_D_L = 0;
   29          float K_P_R = 3000;//800
   30          float K_I_R = 20;//80
   31          float K_D_R = 0;
   32          int16 Right_Duty,Left_Duty;
   33          float right_wheel_goal;
   34          float left_wheel_goal;
   35          
   36          
   37          #define WHEEL_R 32.5       //单位mm
   38          #define WHEEL_POSITION 2*WHELL_R      //
   39          #define ENCODER_POSITON 
   40          #define ENCODER_SPEED
   41          
   42          /* Private Functions ---------------------------------------------------------*/
   43          /* Functions -----------------------------------------------------------------*/
   44          /**
   45            * @brief  左轮速度pid
   46            * @param  goal
   47            * @retval None
   48            */
   49          void left_motor_pid(float goal)
   50          {
   51   1        static float error,last_error=0,last_last_error=0,Goal_speed,error_sum;
   52   1        Goal_speed = (float)(goal-K_diff);
   53   1        left_wheel_goal= Goal_speed;
   54   1        
   55   1      //  if(Goal_speed<2*goal)
   56   1      //    Goal_speed = Goal_speed;
   57   1      //  else Goal_speed = 2*goal;  //两轮差速限幅
C251 COMPILER V5.60.0,  motor_control                                                      13/12/23  20:03:26  PAGE 2   

   58   1        
   59   1        error = Goal_speed - 0.0017f*10*Left_Encoder;            //V = N/1024*（30/68*20.1/100*20*10） = N*0.001
             -7*10 m/s  30为编码器齿轮，68为传动齿轮，20.1为轮子周长，控制周期50ms
   60   1        error_sum += error;
   61   1        Left_Duty =(int)(K_P_L*error+K_I_L*error_sum+K_D_L*(error-2*last_error+last_last_error));
   62   1        
   63   1        last_error = error;
   64   1        last_last_error = last_error;
   65   1        
   66   1      //  Left_Duty -=  position*0.1;
   67   1        Left_Duty = (Left_Duty>8000) ? 8000:Left_Duty;
   68   1        Left_Duty = (Left_Duty<0) ? 0:Left_Duty;
   69   1        
   70   1        
   71   1        Moto_L(Left_Duty);
   72   1        
   73   1      } 
   74          /**
   75            * @brief  右轮速度pid
   76            * @param  goal
   77            * @retval None
   78            */
   79          void right_motor_pid(float goal)
   80          {
   81   1        static float error,last_error=0,last_last_error=0,Goal_speed_R,error_sum;
   82   1        Goal_speed_R = (float)(goal+K_diff);
   83   1        right_wheel_goal = Goal_speed_R;
   84   1      //  
   85   1      //  if (Goal_speed_R<2*goal)
   86   1      //    Goal_speed_R = Goal_speed_R;
   87   1      //  else Goal_speed_R = 2*goal;
   88   1      //  
   89   1        error = Goal_speed_R -0.0017f*10* Right_Encoder;
   90   1        error_sum += error;
   91   1        Right_Duty=(int)(K_P_R*error+K_I_R*error_sum+K_D_R*(error-2*last_error+last_last_error));
   92   1        
   93   1        
   94   1        
   95   1        last_error = error;
   96   1        last_last_error = last_error;
   97   1        
   98   1      //  Right_Duty +=  position*0.1;
   99   1        
  100   1        Right_Duty = Right_Duty>8000 ? 8000:Right_Duty;
  101   1        Right_Duty = Right_Duty<0 ? 0:Right_Duty;
  102   1        
  103   1        Moto_R(Right_Duty);
  104   1        
  105   1      } 
  106          
  107          /**
  108            * @brief  电机外设初始化
  109            * @param  None
  110            * @retval None
  111            */
  112          void motor_init(void)
  113          {
  114   1          pwm_init(PWM_R, 17000, 6000); //初始化PWM1  使用P60引脚  初始化频率为17Khz
  115   1          pwm_init(PWM_L, 17000, 6000); //初始化PWM2  使用P62引脚  初始化频率为17Khz
  116   1        
  117   1          gpio_mode(P6_4, GPO_PP);    //推挽输出
  118   1          gpio_mode(P6_0, GPO_PP);    //
  119   1      
  120   1        //编码器初始化
  121   1         ctimer_count_init(SPEEDL_PLUSE); //初始化定时器0作为外部计数
  122   1         ctimer_count_init(SPEEDR_PLUSE); //初始化定时器3作为外部计数
C251 COMPILER V5.60.0,  motor_control                                                      13/12/23  20:03:26  PAGE 3   

  123   1      }
  124          
  125          
  126          /**
  127            * @brief  获取编码器的值，编码器初始化
  128            * @param  None
  129            * @retval None
  130            */
  131          void Get_Encoder(void)
  132          {
  133   1      //读取采集到的编码器脉冲数
  134   1           Left_Encoder = ctimer_count_read(SPEEDL_PLUSE);
  135   1           Right_Encoder = ctimer_count_read(SPEEDR_PLUSE);
  136   1        
  137   1      //计数器清零
  138   1          ctimer_count_clean(SPEEDL_PLUSE);
  139   1          ctimer_count_clean(SPEEDR_PLUSE);
  140   1      
  141   1      //采集方向信息
  142   1          if(1 == SPEEDL_DIR)
  143   1            Left_Encoder =  Left_Encoder;
*** WARNING C138 IN LINE 143 OF ..\CODE\motor_control.c: expression with possibly no effect
  144   1            else
  145   1            Left_Encoder = -Left_Encoder;
  146   1          if(1 == SPEEDR_DIR)
  147   1            Right_Encoder =-Right_Encoder;
  148   1          else
  149   1            Right_Encoder = Right_Encoder;
*** WARNING C138 IN LINE 149 OF ..\CODE\motor_control.c: expression with possibly no effect
  150   1        
  151   1         Average_Encoder = (Left_Encoder + Right_Encoder)*0.5;
  152   1         distance += (Average_Encoder * 0.07);  //转化为距离  distance=600<――>距离1米
  153   1        
  154   1      }
  155          /**
  156            * @brief  左轮控制
  157            * @param  motor1占空比
  158            * @retval None
  159            */
  160          void Moto_L(int16 moto1)
  161          {
  162   1        if(moto1!=0)
  163   1          {
  164   2            if(moto1<0)       AIN_L=1;
  165   2            else              AIN_L=0;
  166   2          }
  167   1          pwm_duty(PWM_L,myabs(moto1));
  168   1      }
  169          /**
  170            * @brief  右轮控制
  171            * @param  右轮输出占空比
  172            * @retval None
  173            */
  174          void Moto_R(int16 moto2)
  175          {
  176   1        if(moto2!=0)
  177   1          {
  178   2            if(moto2<0)  AIN_R=1;
  179   2            else         AIN_R=0;
  180   2          }
  181   1          pwm_duty(PWM_R,myabs(moto2));
  182   1          
  183   1      }
  184          
  185          void set_pwm(int16 moto1,int16 moto2)
  186          {
C251 COMPILER V5.60.0,  motor_control                                                      13/12/23  20:03:26  PAGE 4   

  187   1        Moto_L(moto1);
  188   1        Moto_R(moto2);
  189   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       670     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        88     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       112     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
