C251 COMPILER V5.60.0,  ADC_Solve                                                          13/12/23  20:03:27  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ADC_Solve
OBJECT MODULE PLACED IN .\Out_File\ADC_Solve.obj
COMPILER INVOKED BY: E:\NIEZS\ARM\KeilC251\C251\BIN\C251.EXE ..\CODE\ADC_Solve.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INC
                    -DIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc
                    -;..\USER\src) DEBUG PRINT(.\Out_File\ADC_Solve.lst) TABS(2) OBJECT(.\Out_File\ADC_Solve.obj) 

stmt  level    source

    1          /**
    2            ******************************************************************************
    3            * @author  Pump_Li
    4            * @version V1.0.0
    5            * @date    2023.3.18
    6            * @brief   adc采集滤波
    7            ******************************************************************************
    8            * @attention
    9            * 
   10            ******************************************************************************
   11            */
   12           /* Includes ------------------------------------------------------------------*/
   13          #include "headfile.h"
   14          #define FILTER_N 5 //滤波次数
   15          uint16 adc_date[4];
   16          float Left_Adc=0,Right_Adc=0,Left_Xie_Adc=0,Right_Xie_Adc=0;
   17          float  adc_max[4]={3800.0,3800.0,3800.0,3800.0};               //最大值
   18          float  adc_min[4]={0.0,0.0,0.0,0.0};               //最小值  (给定一个需要)
   19          float Cha,He;
   20          float temp=0;
   21          /* Functions -----------------------------------------------------------------*/
   22          /**
   23            * @brief  adc初始化
   24            * @param  None
   25            * @retval None
   26            */
   27          void adc_Init_all(){
   28   1        adc_init(Left_ADC_Pin,ADC_SYSclk_DIV_2);             //选择adc引脚，二分频，最高频率
   29   1        adc_init(LeftXie_ADC_Pin,ADC_SYSclk_DIV_2); 
   30   1        adc_init(RightXie_ADC_Pin,ADC_SYSclk_DIV_2); 
   31   1        adc_init(Right_ADC_Pin,ADC_SYSclk_DIV_2); 
   32   1      } 
   33          
   34          /**
   35            * @brief  对电感采值进行冒泡排序滑动滤波
   36            * @param  None
   37            * @retval None
   38            */
   39           void ADC_Date_Fitier()
   40          {
   41   1         uint8 i;
   42   1        
   43   1        uint16 filter_buf_L[FILTER_N];  //左横电感储存数组 
   44   1        uint16 filter_buf_LC[FILTER_N]; //左斜电感储存数组 
   45   1        uint16 filter_buf_R[FILTER_N];  //右横电感储存数组
   46   1        uint16 filter_buf_RC[FILTER_N];  //右斜电感储存数组
   47   1        
   48   1       
   49   1      //--------滑动滤波--------------
   50   1        for(i = 0; i <FILTER_N; i++)//采值 
   51   1        {
   52   2             filter_buf_L[i]  =   adc_mean_filter (Left_ADC_Pin,ADC_12BIT,5); //左横
   53   2             filter_buf_LC[i] =   adc_mean_filter  (LeftXie_ADC_Pin,ADC_12BIT,5); //左斜     
   54   2             filter_buf_RC[i] =  adc_mean_filter  (RightXie_ADC_Pin,ADC_12BIT,5);    //右斜   
   55   2             filter_buf_R[i]  =  adc_mean_filter  (Right_ADC_Pin,ADC_12BIT,5);   //右横  
   56   2         }
   57   1      //--------冒泡排序去极值求平均---------
C251 COMPILER V5.60.0,  ADC_Solve                                                          13/12/23  20:03:27  PAGE 2   

   58   1        adc_date[0]= Final_Average_Filter(filter_buf_L);//左      3800
   59   1        adc_date[1] =Final_Average_Filter(filter_buf_R);//右      3800
   60   1        adc_date[2] = Final_Average_Filter(filter_buf_LC);//左斜  3800
   61   1        adc_date[3] = Final_Average_Filter(filter_buf_RC);//右斜  3800
   62   1      
   63   1        normalize_date();//归一化处理
   64   1         
   65   1      //  Left_Adc = adc_date[0];//左电感最终值
   66   1      //  Right_Adc = adc_date[1];//右电感最终值 
   67   1      //  Left_Xie_Adc = adc_date[2];//左斜电感最终值 
   68   1      //  Right_Xie_Adc = adc_date[3];//右斜电感最终值
   69   1      
   70   1      
   71   1       
   72   1      
   73   1      }
   74          /**
   75            * @brief  对电感采值去最大值最小值取平均
   76            * @param  None
   77            * @retval None
   78            */
   79          uint16 Final_Average_Filter(uint16 *Date)
   80          {
   81   1        uint8 i;
   82   1        uint16 max,min;
   83   1        uint16 sum=0;
   84   1        
   85   1        max = Date[0];
   86   1        min = Date[0];
   87   1        
   88   1        for(i=0;i<5;i++)
   89   1        {
   90   2             if(max<Date[i]) max = Date[i];
   91   2             if(min>Date[i]) min = Date[i];
   92   2             sum += Date[i];
   93   2        }       
   94   1        sum = (sum-max-min)/(5-2);
   95   1        return sum;
   96   1      }
   97          /**
   98            * @brief  归一化处理,结算值结果在0~1000
   99            * @param  None
  100            * @retval None
  101            */
  102          void normalize_date()
  103          {
  104   1        float temp_Date[4];
  105   1        uint16 i;
  106   1        for(i=0;i<4;i++)
  107   1        {
  108   2      //    if(adc_date[i]<adc_min[i])
  109   2      //    {
  110   2      //      adc_min[i]=adc_date[i];
  111   2      //    }
  112   2      //   else if(adc_date[i]>adc_max[i])
  113   2      //   {  
  114   2      //   adc_max[i]=adc_date[i];
  115   2      //   } 
  116   2           temp_Date[i] = (adc_date[i]-adc_min[i])/(adc_max[i]-adc_min[i])*500;
  117   2          if (temp_Date[i]<0)
  118   2          {
  119   3            temp_Date[i]=0.0;
  120   3          }
  121   2            else if(temp_Date[i]>500.0)
  122   2            {
  123   3            temp_Date[i]=500.0;
C251 COMPILER V5.60.0,  ADC_Solve                                                          13/12/23  20:03:27  PAGE 3   

  124   3            }
  125   2            }
  126   1        Left_Adc = temp_Date[0];//左电感最终值
  127   1        Right_Adc = temp_Date[1];//右电感最终值 
  128   1        Left_Xie_Adc = temp_Date[2];//左斜电感最终值
  129   1        Right_Xie_Adc = temp_Date[3];//右斜电感最终值
  130   1      }
  131          
  132          ///*****************差比和差***********************
  133          //函数： int16 Cha_BI_He_Cha(uint16 Date_1,uint16 Date_2,uint16 Date_3,uint16 Date_4,float a,float b,uint
             -16 X)
  134          //参数：  float Date_1--左横电感  float Date_2--右横电感 
  135          //        float Date_3--左斜电感  float Date_4--右斜电感 
  136          //        float a--横电感加权系数  float b-- 斜电感加权系数   int16 X--左移位数
  137          //说明：  无
  138          //返回值：Resault
  139          //日期：2022-3-28
  140          //最后修改时间：2022-3-28
  141          //作者：       */
  142          //int16 Cha_BI_He_Cha(uint16 Date_1,uint16 Date_2,uint16 Date_3,uint16 Date_4,float a,float b,uint16 X)
  143          //{
  144          //  int16 Resault;
  145          //  int16 FengZ,FengM;
  146          //  Cha_H =  (int16)((Date_1 - Date_2));   //横电感差
  147          //  Cha_X =  (int16)((Date_3 - Date_4));   //斜电感差
  148          //  
  149          //  He =   Date_1 + Date_2;   //横电感和
  150          //  Sum = Date_1 + Date_2 + Date_3 + Date_4;  //所有电感之和
  151          //  He_X = Date_3 + Date_4; //斜电感和
  152          //  
  153          //  FengZ = a*Cha_H+b*Cha_X;  
  154          //  FengM = a*He+b*myabs(Cha_X);
  155          //  Resault = ((FengZ<<X)/(FengM+1)); //差比和差
  156          //  return   Resault;
  157          //}
  158          
  159          
  160          //////////去除极值求平均
  161          //int16 I_Median_Average_Filter(int16 *DATE)
  162          //{
  163          //    uint8 i;
  164          //    int16 max,min;  //定义极值以及和
  165          //    int16 sum = 0;
  166          
  167          //    max = DATE[0];
  168          //    min = DATE[0];
  169          
  170          //    for(i=0;i<sizeof(DATE);i++)
  171          //    {
  172          //        if(max<DATE[i]) max = DATE[i];
  173          //        if(min>DATE[i]) min = DATE[i];
  174          //        sum += DATE[i];
  175          //    }
  176          
  177          //    sum =(sum-max-min)/(sizeof(DATE)-2);    //>>3
  178          //    return sum;
  179          //}
  180          /*****************差比和***********************
  181          函数： float Cha_BI_He(float Date_1,float Date_2,int16 X)
  182          参数：  float Date_1--第一个数据  float Date_2--第二个数据  int16 X--左移位数
  183          说明：  无
  184          返回值：无
  185          日期：2022-3-19
  186          最后修改时间：2022-3-19
  187          作者：      */
  188          float Cha_BI_He(float Date_1,float Date_2)
C251 COMPILER V5.60.0,  ADC_Solve                                                          13/12/23  20:03:27  PAGE 4   

  189          {
  190   1        float Resault;
  191   1        Cha =  (Date_1 - Date_2);   //差
  192   1        He =   Date_1 + Date_2;   //和
  193   1        //Resault = (Cha<<X/(He+1)) ; //差比和
  194   1        Resault = Cha / (He+1);
  195   1      
  196   1      
  197   1        return   Resault;
  198   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       430     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        68         56
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        80     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
